/*
README.md


TO RUN :
	$ g++ bunny.cpp -o bunnyy -lglut -lGLU -lGL
	$ ./bunnyy

TO SCALE :
	scroll-up to scale-up
	scroll-down to scale-down

TO ROTATE :
	click and move mouse to rotate



- reading from file "stbunny.txt" in main function.
  stored as set of facets/triangles of 3vertices each, in a vector
- scrollScaler() to detect mouse clicks and scrolls for scaling and rotating
- rotater() to determine rotation
- renderFunction() is the display callback

*/


#include<iostream>
#include<fstream>
#include<vector>

#include<GL/freeglut.h>
#include<GL/gl.h>

using namespace std;

#define DIM 3
typedef GLfloat tPointi[DIM];
struct facet{
	tPointi v1;
	tPointi v2;
	tPointi v3;
};
vector<struct facet> facets;
bool button_state=false;
GLfloat px=0.0,py=0.0,xrot=0.0,yrot=0.0;
float scalef=1;

// each vertex of 3d, is of type tPointi which is a GLfloat array of size 3.
// each facet will have 3vertices, and to get them, we have the struct facet
// to store all facets, a vector is used(facets)
// button_state : to detect if button is still pressed(for rotation)
// scalef for scaling



// glutDisplayFunc display callback; to draw/render the model every time it must be redrawn
void renderFunction(){
	glClearColor(1.0,1.0,1.0,1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.0,0.0,1.0);
	
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);     
	glDisable(GL_CULL_FACE);

	//to perform scaling
	glScaled(scalef,scalef,scalef);

	//if it is in rotation state, to perform rotation
	if(button_state){
		glRotated(-1,xrot,yrot,0);
	}

	glBegin(GL_TRIANGLES);
		for(auto it=begin(facets);it!=end(facets);it++){
			glVertex3f(it->v1[0],it->v1[1],it->v1[2]);
			glVertex3f(it->v2[0],it->v2[1],it->v2[2]);
			glVertex3f(it->v3[0],it->v3[1],it->v3[2]);
      	}
	glEnd();

	glFlush();
}


//callback for glMouseFunc
//depending on button pressed, corresponding action will e taken.
//button 3 and 4 => scrollup and down, for scaling up and down respectively
//other case is for detecting mouse click for rotation purposes
//GLUT_DOWN => if it is in clicked position
void scrollScaler(int button,int state,int x,int y){
	if(button==3){
		button_state=false;
		scalef=1.01;
	}
	else if(button==4){
		button_state=false;
		scalef=0.99;
	}
	else{
		if(state==GLUT_DOWN){
			scalef=1;
			button_state=true;
			px=x;
			py=400-y;
		}
	}
	glutPostRedisplay();
}

//callback for glutMotionFunc, for when rotation is to happen
void rotater(int x,int y){
	if(button_state){
		xrot=(x-px);
		yrot=(py-y);
		glutPostRedisplay();
		px=x;
		py=y;
	}
}


int main(int argc, char** argv)
{
	ifstream iFile("stbunny.txt",ios::in);
	
	//to discard file header - "solid STL generated by MeshLab"
	//as remaining data is the same, can be read from while
	string header;
	getline(iFile,header);

	while(getline(iFile,header)){
		//break from loop on reaching eof
		if(header=="endsolid vcg"){
			break;
		}
		getline(iFile,header); 

		//read the 3 sets of vertices of each facet
		string v;
		tPointi pd1,pd2,pd3;
		iFile>>v>>pd1[0]>>pd1[1]>>pd1[2];
		iFile>>v>>pd2[0]>>pd2[1]>>pd2[2];
		iFile>>v>>pd3[0]>>pd3[1]>>pd3[2];

		//init a struct facet object and each facet(object) is added to a vector of facets
		struct facet fac;
		fac.v1[0]=pd1[0];
		fac.v1[1]=pd1[1];
		fac.v1[2]=pd1[2];

		fac.v2[0]=pd2[0];
		fac.v2[1]=pd2[1];
		fac.v2[2]=pd2[2];

		fac.v3[0]=pd3[0];
		fac.v3[1]=pd3[1];
		fac.v3[2]=pd3[2];


		facets.push_back(fac);

		//to deal with endloop and endfacet of each set
		getline(iFile,header); 
		getline(iFile,header); 
		getline(iFile,header);
	}

	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_SINGLE);
	glutInitWindowSize(500,400);
	glutInitWindowPosition(200,100);
	glutCreateWindow("B170162CS");
	glOrtho(-100.0,100.0,-100.0,100.0,-100.0,100.0);
	glutDisplayFunc(renderFunction);

	glutMouseFunc(scrollScaler);
	glutMotionFunc(rotater);

	iFile.close();
	glutMainLoop();
	return 0;
}